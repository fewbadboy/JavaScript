## 组件注册
DOM中使用的时候只有Kebab-case是有效的；字符串模板和单文件中kebab-case和PascalCase都可以

## Props
父组件传递prop时：，不管数字，布尔，数组还是对象都用v-bind告诉Vue 这是一个表达式

单向数据流：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。每次父级组件发生变更时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop
两种常见的改变prop的情形：
- 这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。在这种情况下，最好定义一个本地的 data property 并将这个 prop 作为其初始值
```js
props: ['initialCounter'],
data() {
  return {
    counter: this.initialCounter
  }
}
```
- 这个 prop 以一种原始的值传入且需要进行转换
```js
props: ['size'],
computed: {
  normalizedSize() {
    return this.size.trim().toLowerCase()
  }
}
```
*注意*：
avaScript 中对象和数组是通过引用传入的，所以对于一个数组或对象类型的 prop 来说，在子组件中改变变更这个对象或数组本身将会影响到父组件的状态

验证
```js
app.component('my-component', {
  props: {
    // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)
    propA: Number/String/Boolean/Array/Object/Date/Function/Symbol,
    // 多个可能的类型
    propB: [String, Number],
    // 必填的字符串
    propC: {
      type: String,
      required: true
    },
    // 带有默认值的数字
    propD: {
      type: Number,
      default: 100
    },
    // 带有默认值的对象
    propE: {
      type: Object,
      // 对象或数组默认值必须从一个工厂函数获取
      default() {
        return { message: 'hello' }
      }
    },
    // 自定义验证函数
    propF: {
      validator(value) {
        // 这个值必须匹配下列字符串中的一个
        return ['success', 'warning', 'danger'].includes(value)
      }
    },
    // 具有默认值的函数
    propG: {
      type: Function,
      // 与对象或数组默认值不同，这不是一个工厂函数 —— 这是一个用作默认值的函数
      default() {
        return 'Default function'
      }
    }
  }
})
```

## 非Prop的Attribue
如果你不希望组件的根元素继承 attribute，你可以在组件的选项中设置 `inheritAttrs: false`,然后访问组件`$attrs`属性,该属性包括组件 props 和 emits 属性 中未包含的所有属性。
```js
app.component('date-picker', {
  inheritAttrs: false,
  template: `
    <div class="date-picker">
      <input type="datetime-local" v-bind="$attrs" />
    </div>
  `
})
```

多个根节点需要显示绑定`$attrs`
```js
app.component('custom-layout', {
  template: `
    <header>...</header>
    <main v-bind="$attrs">...</main>
    <footer>...</footer>
  `
})
```

## 自定义事件
```html
<my-component @my-event="doSomething"></my-component>
```

```js
this.$emit('myEvent')
```
emits 选项定义已发出的事件
```js
app.component('custom-form', {
  emits: ['myEvent']
})
// 验证
app.component('custom-form', {
  emits: {
    // 没有验证
    click: null,

    // 验证submit 事件
    submit: ({ email, password }) => {
      if (email && password) {
        return true
      } else {
        console.warn('Invalid submit event payload!')
        return false
      }
    }
  },
  methods: {
    submitForm(email, password) {
      this.$emit('submit', { email, password })
    }
  }
})
```

v-model参数:组件上的 v-model 使用 modelValue 作为 prop 和 update:modelValue 作为事件。我们可以通过向 v-model 传递参数来修改这些名称
`<my-component v-model:title="bookTitle"></my-component>`
```js
app.component('my-component', {
  props: {
    title: String
  },
  emits: ['update:title'],
  template: `
    <input
      type="text"
      :value="title"
      @input="$emit('update:title', $event.target.value)">
  `
})
```
`同时多个v-model可以绑定在一个自定义组件上`

自定义修饰符(除了内置的lazy,number,trim)
```js
// <my-component v-model.capitalize="myText"></my-component>
app.component('my-component', {
  props: {
    modelValue: String,
    modelModifiers: {
      default: () => ({})
    }
  },
  emits: ['update:modelValue'],
  methods: {
    emitValue(e) {
      let value = e.target.value
      if (this.modelModifiers.capitalize) {
        value = value.charAt(0).toUpperCase() + value.slice(1)
      }
      this.$emit('update:modelValue', value)
    }
  },
  template: `<input
    type="text"
    :value="modelValue"
    @input="emitValue">`
})
```


## 插槽


## Provide/Inject


## 动态组件和异步组件


## 模板引用


## 处理边界情况
